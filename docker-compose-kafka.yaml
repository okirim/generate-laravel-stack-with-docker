@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
        basePackages = "com.example.report.repo",
        entityManagerFactoryRef = "reportEntityManager",
        transactionManagerRef = "reportTxManager"
)
public class SecondaryDbConfig {

    @Bean
    @ConfigurationProperties("secondary.datasource")
    public DataSourceProperties reportDsProps() {
        return new DataSourceProperties();
    }

    @Bean
    public DataSource reportDataSource() {
        return reportDsProps().initializeDataSourceBuilder().build();
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean reportEntityManager(EntityManagerFactoryBuilder builder) {
        return builder
                .dataSource(reportDataSource())
                .packages("com.example.report.entity")
                .persistenceUnit("reportPU")
                .build();
    }



@Service
public class AppService {

    @Autowired
    private TestAppRepository repo;

    @Transactional  // datasource par défaut
    public void saveApp(String name) {
        repo.save(new TestApp(name));
    }
}

@Service
public class ReportService {

    @Autowired
    private TestReportRepository repo;

    @Transactional("reportTxManager")  // datasource secondaire
    public void saveReport(String description) {
        repo.save(new TestReport(description));
    }
}

    @Bean
    public PlatformTransactionManager reportTxManager(@Qualifier("reportEntityManager") EntityManagerFactory emf) {
        return new JpaTransactionManager(emf);
    }

    @Bean(initMethod = "migrate")
    public Flyway reportFlyway() {
        return Flyway.configure()
                .dataSource(reportDataSource())
                .locations("classpath:db/migration/report")
                .baselineOnMigrate(true)
                .load();
    }
}
Mais avec deux BDD + Flyway, il y a 3 pièges classiques :

Flyway s’auto-lance sur la BDD principale via l’auto-config Spring Boot

Ta BDD secondaire n’est pas gérée par cette auto-config

Tu dois pouvoir activer/désactiver indépendamment les migrations de chaque BDD

La clé = désactiver l’auto Flyway global, puis déclarer 2 beans Flyway manuels, chacun piloté par des properties.


@Bean(initMethod = "migrate")
@ConditionalOnProperty(prefix = "app.flyway.main", name = "enabled", havingValue = "true")
public Flyway mainFlyway(@Qualifier("mainDataSource") DataSource ds) {
    return Flyway.configure()
            .dataSource(ds)
            .locations("classpath:db/migration/main")
            .baselineOnMigrate(true)
            .load();
}

@Bean(initMethod = "migrate")
@ConditionalOnProperty(prefix = "app.flyway.report", name = "enabled", havingValue = "true")
public Flyway reportFlyway(@Qualifier("reportDataSource") DataSource ds) {
    return Flyway.configure()
            .dataSource(ds)
            .locations("classpath:db/migration/report")
            .baselineOnMigrate(true)
            .load();
}

app:
  flyway:
    main:
      enabled: true
    report:
      enabled: true

